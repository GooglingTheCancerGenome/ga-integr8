#!/usr/bin/env python__author__ = "Marleen Nieboer"__credits__ = []__maintainer__ = "Marleen Nieboer"__email__ = "m.m.nieboer@umcutrecht.nl"__status__ = "Development"import syssys.path.append('settings/') #Add settings pathimport settingsimport numpy as npimport time#Separate class to do the overlap functionality.#It would be great if all functionality to obtain annotations would each be in separate classes. These can then also be swapped out if needed. #Maybe it is good to also have some sort of interface to write against to make sure that all classes are always in the same format (with the same functions). class GeneListFeatureHandler:		#Annotate will accept all SVs that need to be annotated, and return the annotations for these SVs.	#SVs format:	#annotations format: a dictionary with annotations. {'featureName' : [values]}, where values is in the same order as the SVs. 		#enabledFeatures is an optional parameter. A list can be provided that contains the names of features that are enabled in the settings. If necessary, certain features that have been disabled	#do not need to be obtained from the file, or do not need to be computed to save computational time.	def annotate(self, regions, enabledFeatures = None):				#Read the gene list file and obtain the features		#Do overlap with the provided regions				#1. Load the gene list file		geneListData = self.readGeneListFile()				#2. Make sure that the gene list file is sorted (currently it is sorted, so no need)				#3. Determine which gene each SV is closest to and compute the features that we are interested in		annotations = self.computeNearestGeneFeatures(regions, geneListData)		return annotations		#This function currently only reads the start, end and chromosome for easy testing. We can later return everything on the entire line and then select which ones we want based on the settings	def readGeneListFile(self):				geneListFile = settings.inputFiles['geneList']				#Read the gene list data into a list		geneListData = []		with open(geneListFile, "r") as f:			lineCount = 0			for line in f:				if lineCount < 2: #skip header					lineCount += 1					continue				line = line.strip()				splitLine = line.split("\t")								#We are interested in the positional information to see which gene is closest. (Add more later)								#Convert the numbers to integers for quicker comparison. 5 is start, 6 is end				splitLine[5] = int(splitLine[5])				splitLine[6] = int(splitLine[6])								splitLine[4] = str(splitLine[4])								#chr, start, end, pLI, RVIS, HPO ids, HGNC symbol				geneListData.append([splitLine[4], splitLine[5], splitLine[6], splitLine[10], splitLine[11], splitLine[14], splitLine[0]])				#Also convert the other dataset to numpy		geneListData = np.array(geneListData, dtype='object')			return geneListData		#TO DO: split this function up in separate, more readable sub-functions	def computeNearestGeneFeatures(self, regions, geneListData):				#Keep the annotations as a dictionary		annotations = dict()		annotations['nearestGeneDistance'] = [] #save as a list where every entry is the nearest gene distance for an SV		annotations['pLI'] = []		annotations['RVIS'] = []		annotations['HPO'] = [] 		#The input regions are sorted, so we can make chromosomal subsets. 				previousChr1 = None		previousChr2 = None		startTime = time.time()		for lineCount in range(0, len(regions)):			#print lineCount			#Make sure to filter the dataset per chromosome! Good when sorted, we can keep it until we hit the next chromosome			#The genes are not cross-chromosomal, but translocations can be, so we need to check both chromosome entries!						#Obtain start and end positions and chromosome (chr 1 and 2)			lineList = regions[lineCount,:]						#print geneListData						#We should check the chromosome of the previous line.			#This would work nicely if the input file has been properly sorted! We probably need a pre-sorting to make this work. 			if str(lineList[0]) != previousChr1 and str(lineList[3]) != previousChr2:								#Find the two subsets that match on both chromosomes. 				matchingChr1Ind = geneListData[:,0] == lineList[0]				matchingChr2Ind = geneListData[:,0] == lineList[3] #The gene list entry is here the same since the genes are only on 1 chromosome. 								#It is not even necessary to make 2 lists if both chromosomes are the same, we could use a reference without re-allocating				geneListChr1Subset = geneListData[np.where(matchingChr1Ind)]				if lineList[0] == lineList[3]:					geneListChr2Subset = geneListChr1Subset				else:					geneListChr2Subset = geneListData[np.where(matchingChr2Ind)]								#Make sure to update the previous chromosome when it changes				previousChr1 = str(lineList[0])				previousChr2 = str(lineList[3])										if np.size(geneListChr1Subset) < 1 and np.size(geneListChr2Subset) < 1:				continue #no need to compute the distance, there are no genes on these chromosomes						#It is a bit inefficient to do the astype here, but I already cast to int in the annotation tester, why did it get lost? 			start = lineList[1].astype(int) #only do the conversion once. Why is this not remembered from the previous loop?			end = lineList[2].astype(int)			coordinates1 = np.array([start,end])			coordinates2 = np.array([end,start]) #Also reverse to check if there is an end closer to a start						#Instead of the nearest gene, we can look at all genes within 2 Mb of the SV						geneDistance = settings.parameters['geneDistance']						#Compute the absolute distance, then remove the genes that are not within 2Mb and use this as a subset.						#The genes are assumed to be sorted, so we can compute if these are within 2Mb by only comparing the nearest coordinate.					startOverlap = start - geneDistance < geneListChr1Subset[:,2] 			endOverlap = end + geneDistance > geneListChr1Subset[:,1]						#Now find where both of these are true (multiply because both conditions need to be true)			distanceMatchesChr1 = startOverlap * endOverlap						#Repeat for the second chromosome			startOverlap = start - geneDistance < geneListChr2Subset[:,2] 			endOverlap = end + geneDistance > geneListChr2Subset[:,1]						distanceMatchesChr2 = startOverlap * endOverlap						#obtain indices of matches, obtain the information of these genes						matchIndChr1 = np.where(distanceMatchesChr1 == True)[0] #This creates an array in array, we are only interested in the first that contains the matching indices			matchIndChr2 = np.where(distanceMatchesChr2 == True)[0]						matchingGenesChr1 = geneListChr1Subset[matchIndChr1, :]			matchingGenesChr2 = geneListChr2Subset[matchIndChr2, :]						#Obtain information about the matching genes (for now only the identifier)						#geneIdsChr1 = matchingGenesChr1[:,6]			#geneIdsChr2 = matchingGenesChr2[:,6]									#geneIds = set(np.concatenate((geneIdsChr1, geneIdsChr2), axis=0))						matchingGenes = np.concatenate((matchingGenesChr1, matchingGenesChr2), axis=0)			geneIds = matchingGenes[:,6]			#store the number of genes in annotations. Later the indices or identifiers would be relevant (multiple features, linking)			annotations['nearestGeneDistance'].append(len(geneIds))												#For each of these genes, also report the pLI and RVIS scores (hpo terms? not yet relevant)			pLiScores = []			rvisScores = []			for gene in matchingGenes:												pLi = gene[3]				RVIS = gene[4]				pLiScores.append(pLi)				rvisScores.append(RVIS)						annotations['pLI'].append(','.join(pLiScores))			annotations['RVIS'].append(','.join(rvisScores))									#Make 8 distance comparisons (start to gene start and end, end to gene start and end, in both chromosome subsets). We can comparess it to 4						#We could probably make this into 2 by further concatenating matrices, but I don't know if that saves any run time at all. 						#Compute the differences from the start and end of the SVs to all other regions. (This is the slowest part)			#chr1DifferencesStart = np.subtract(coordinates1, geneListChr1Subset[:,1:2])			#chr1DifferencesStart = np.abs(np.subtract(coordinates1, geneListChr1Subset[:,1:2]))			#chr1DifferencesEnd = np.abs(np.subtract(coordinates2, geneListChr1Subset[:,1:2]))			#chr2DifferencesStart = np.abs(np.subtract(coordinates1, geneListChr2Subset[:,1:2]))			#chr2DifferencesEnd = np.abs(np.subtract(coordinates2, geneListChr2Subset[:,1:2]))						#Check if any of the coordinates is within 2 Mb. If true, subset these genes.												#### Previous nearest gene queries			# 			# #Order (ascending). This does need to be done per column, otherwise the ordering is not helpful.			# 			# chr1StartToGeneStartDifferenceOrderedInd = np.argsort(chr1DifferencesStart[:,0])			# chr1StartToGeneEndDifferenceOrderedInd = np.argsort(chr1DifferencesEnd[:,1])			# chr1EndToGeneStartDifferenceOrderedInd = np.argsort(chr1DifferencesEnd[:,0])			# chr1EndToGeneEndDifferenceOrderedInd = np.argsort(chr1DifferencesStart[:,1])			# 			# chr2StartToGeneStartDifferenceOrderedInd = np.argsort(chr2DifferencesStart[:,0])			# chr2StartToGeneEndDifferenceOrderedInd = np.argsort(chr2DifferencesEnd[:,1])			# chr2EndToGeneStartDifferenceOrderedInd = np.argsort(chr2DifferencesEnd[:,0])			# chr2EndToGeneEndDifferenceOrderedInd = np.argsort(chr2DifferencesStart[:,1])			# 			# #differences = [chr1StartToGeneStartDifference[chr1StartToGeneStartDifferenceOrderedInd[0]]]			# 			# differences = [chr1DifferencesStart[chr1StartToGeneStartDifferenceOrderedInd[0]][0],			# 					chr1DifferencesEnd[chr1StartToGeneEndDifferenceOrderedInd[0]][1],			# 					chr1DifferencesEnd[chr1EndToGeneStartDifferenceOrderedInd[0]][0],			# 					chr1DifferencesStart[chr1EndToGeneEndDifferenceOrderedInd[0]][1],			# 					chr2DifferencesStart[chr2StartToGeneStartDifferenceOrderedInd[0]][0],			# 					chr2DifferencesEnd[chr2StartToGeneEndDifferenceOrderedInd[0]][1],			# 					chr2DifferencesEnd[chr2EndToGeneStartDifferenceOrderedInd[0]][0],			# 					chr2DifferencesStart[chr2EndToGeneEndDifferenceOrderedInd[0]][1]	]			# 			# #Find smallest value			# minDifferenceInd = np.argmin(differences)			# 			# #Obtain the minimum difference			# minDifference = differences[minDifferenceInd]			# 			# #If the smallest difference comes from the second difference check, we should obtain the start to end gene. Use the indices to figure out the related gene. 			# #differenceIndices = [chr1StartToGeneStartDifferenceOrderedInd[0]]			# 			# differenceIndices = [chr1StartToGeneStartDifferenceOrderedInd[0],			# 					chr1StartToGeneEndDifferenceOrderedInd[0],			# 					chr1EndToGeneStartDifferenceOrderedInd[0],			# 					chr1EndToGeneEndDifferenceOrderedInd[0],			# 					chr2StartToGeneStartDifferenceOrderedInd[0],			# 					chr2StartToGeneEndDifferenceOrderedInd[0],			# 					chr2EndToGeneStartDifferenceOrderedInd[0],			# 					chr2EndToGeneEndDifferenceOrderedInd[0]]			# 			# 			# nearestGeneInd = differenceIndices[minDifferenceInd]			# 			# #Obtain other features from the nearest gene			# #print nearestGeneInd			# geneInfo = geneListData[nearestGeneInd, :]			# 			# 			# #print "region: ", lineList			# 			# annotations['nearestGeneDistance'].append(minDifference)			# annotations['pLI'].append(geneInfo[3])			# annotations['RVIS'].append(geneInfo[4])			# annotations['HPO'].append(geneInfo[5])						#### End nearest gene queries									#Append more features. Leave it for now to simply test the speed of the algorithm. Extracting two more values from a line will not change performance significantly. 		endTime = time.time()		print "total time to query: ", endTime - startTime		return annotations	#More functions to be added 				