#!/usr/bin/env python__author__ = "Marleen Nieboer"__credits__ = []__maintainer__ = "Marleen Nieboer"__email__ = "m.m.nieboer@umcutrecht.nl"__status__ = "Development"#Class that will handle obtaining the features from the flat files.#Class naming is not the best, but ok#Every function will look at the associated settings file to see if the features have been enabled.#All the files are grouped by a type (TAD, enhancers, PCHiC, Genes). There should not be different functions that read the same type of data multiple times to prevent slowdown. import settings#Import the classes that interact with the files directlyfrom geneListFeatureHandler import GeneListFeatureHandlerfrom tadFeatureHandler import TADFeatureHandlerclass FlatFileDB:			#I keep the annotations separate from the SVs for now, so that the original data can be re-used without having been updated multiple times already. 	def computeNearestGeneFeatures(self, regions):				#Given the formatted data, do the overlap with the gene list file.		#I think it will be a good idea to do these overlap computations in a GeneListFeatureHandler class rather than here				#Initiate the gene list handler		geneListFeatureHandler = GeneListFeatureHandler()		annotations = geneListFeatureHandler.annotate(regions)				#Ask the gene list handler to annotate. 				#I'm not sure yet if these settings should actually make sure that specific features are not obtained (not very useful for now since everything is on one row anyway),		#or if this should be part of the object that communicates with the file, such that it also does not try to obtain those features if disabled (could save computational time)		#if settings.features['NearestGene'] is True:		#	a = 1				return annotations			def computeTADFeatures(self, SVs):				tadFeatureHandler = TADFeatureHandler()		annotations = tadFeatureHandler.annotate(SVs)				return annotations			def computeEnhancerFeatures(self, SVs):				1+1			def computePCHiCFeatures(self, SVs):				1+1			